# Билет 1

## Абстрактные типы данных в программировании. Ассоциативные массивы и списки.

**Определить их словесно или с использованием схем, основные операции над ними. Показать их вычислительную сложность.**

---

## Абстрактные типы данных (АТД)
Абстрактный тип данных (АТД) — это логическая модель структуры данных, которая определяет допустимые операции и их поведение, **не раскрывая конкретную реализацию**.
АТД задаёт интерфейс, а не реализацию.  
Примеры: список, стек, очередь, множество, словарь.

---
## Список (List)
Список — это упорядоченная коллекция элементов, в которой:
- Каждый элемент имеет индекс
- Допускаются повторяющиеся значения

### Основные операции и их сложности (при реализации через массив):

|Операция|Описание|Сложность|
|---|---|---|
|`A[i]`|доступ по индексу|`O(1)`|
|`append(x)`|добавление в конец|`O(1)` (в среднем)|
|`insert(i, x)`|вставка в начало/середину|`O(n)`|
|`pop(i)` / `del A[i]`|удаление по индексу|`O(n)`|
|`x in A`|поиск по значению|`O(n)`|

Типичные реализации: динамический массив, односвязный или двусвязный список.

---
## Ассоциативный массив (словарь / dictionary / map)

Ассоциативный массив — это структура данных, хранящая пары **ключ → значение**.  
Ключи уникальны, доступ к значению осуществляется по ключу.

### Основные операции и их сложности (в реализации через хеш-таблицу):
|Операция|Пример|Сложность|
|---|---|---|
|доступ по ключу|`D[k]`|`O(1)` (в среднем)|
|добавление|`D[k] = v`|`O(1)`|
|удаление|`del D[k]`|`O(1)`|
|проверка наличия ключа|`k in D`|`O(1)`|
|перебор всех элементов|`for k, v in D.items()`|`O(n)`|

Типичные реализации: хеш-таблица (средняя сложность `O(1)`), реже — сбалансированное дерево (`O(log n)`).

---

## Сравнение списка и словаря

|Свойство|Список|Ассоциативный массив|
|---|---|---|
|Доступ|По индексу|По ключу|
|Упорядоченность|Есть|Не гарантируется (в хеш-таблице)|
|Повторы|Разрешены|Ключи уникальны|
|Быстрый доступ|`O(1)` по индексу|`O(1)` по ключу|
|Перебор|По порядку|В произвольном порядке|

---

## Выводы

- АТД описывают, **что можно делать с данными**, а не как именно они устроены.
- Список — простая структура с доступом по индексу, удобен для последовательных данных.
- Ассоциативный массив — структура с доступом по ключу, эффективна для поиска и отображений.
- Оба типа данных — фундаментальны и часто используются в программировании.
# Билет 2

## Древовидные структуры (деревья бинарные, сбалансированные, сильноветвящиеся).

**Определить их словесно или с использованием схем. Основные операции над ними (поиск, вставка, удаление). Показать вычислительную сложность.**

---

## Дерево

Дерево — это иерархическая структура данных, в которой:
- Каждый элемент называется **узлом**
- Один узел — **корень**
- У каждого узла могут быть **потомки** (дети)
- Связи между узлами называются **рёбрами**
---
## Бинарное дерево
Бинарное дерево — дерево, где каждый узел имеет не более двух потомков: **левый** и **правый**.
**Бинарное дерево поиска (BST)** — структура, в которой:
- Все значения в левом поддереве меньше текущего узла
- Все значения в правом поддереве больше текущего узла
### Сложности (в среднем):
- Поиск: `O(log n)`
- Вставка: `O(log n)`
- Удаление: `O(log n)`
### В худшем случае (несбалансированное дерево):
- Все операции — `O(n)`
---
## Сбалансированное дерево
Сбалансированное дерево — это бинарное дерево, у которого высота левого и правого поддеревьев отличается не более чем на 1 (например, AVL-дерево или красно-чёрное дерево).
**Преимущество:** гарантированная логарифмическая высота.
### Сложности (всегда):
- Поиск: `O(log n)`
- Вставка: `O(log n)`
- Удаление: `O(log n)
Баланс поддерживается с помощью поворотов при вставке и удалении
---
## Сильноветвящиеся деревья
Сильноветвящееся (n-арное) дерево — это дерево, в котором каждый узел может иметь более двух детей.
Пример: **B-деревья** — используются в базах данных и файловых системах.
### Сложности (в среднем и в худшем случае при балансировке):
- Поиск: `O(log n)`
- Вставка: `O(log n)`
- Удаление: `O(log n)`
У таких деревьев меньше высота, за счёт широкой ветвистости.
---
## Сравнение деревьев

|Вид дерева|Потомков|Балансировка|Высота|Сложность операций|
|---|---|---|---|---|
|Бинарное|≤ 2|Нет|до `n`|До `O(n)`|
|Сбалансированное|≤ 2|Есть|`O(log n)`|`O(log n)`|
|Сильноветвящееся|> 2|Есть|`O(log n)`|`O(log n)`|

---
## Выводы
- Деревья позволяют эффективно хранить и искать данные в иерархической форме.
- Бинарные деревья просты, но могут деградировать без балансировки.
- Сбалансированные деревья обеспечивают надёжную производительность.
- Сильноветвящиеся деревья лучше подходят для работы с большими объёмами данных.

# Билет 3

## Понятие рекурсии в программировании. Рекурсивные и нерекурсивные алгоритмы.

**Условия окончания работы. Привести примеры рекурсивного и нерекурсивного алгоритмов, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.**

---

## Рекурсия

Рекурсия — это приём в программировании, при котором **функция вызывает саму себя** для решения подзадачи. Каждое новое рекурсивное вызов создаёт копию функции со своими локальными переменными.

---

## Условия корректной рекурсии
1. **Базовый случай** — условие, при котором рекурсивные вызовы прекращаются.
2. **Рекурсивный шаг** — переход к подзадаче меньшего размера.

Без базового случая произойдёт бесконечный цикл вызовов и переполнение стека.

---

## Пример рекурсивного алгоритма — факториал
Факториал числа `n` (`n!`) — это произведение всех чисел от `1` до `n`.
Рекурсивное определение:
- `0! = 1` (базовый случай)
- `n! = n * (n - 1)!` (рекурсивный шаг)

Рекурсивная реализация:
```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```
**Сложность по времени:** `O(n)`  
**Сложность по памяти:** `O(n)` (из-за стека вызовов)

---

## Пример нерекурсивного алгоритма — факториал (итеративно)

```python
def factorial_iter(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```
**Сложность по времени:** `O(n)`  
**Сложность по памяти:** `O(1)`

---
## Рекурсивные и нерекурсивные алгоритмы: сравнение

|Характеристика|Рекурсивный подход|Нерекурсивный (итеративный) подход|
|---|---|---|
|Простота записи|Чаще проще и короче|Иногда сложнее|
|Память|Использует стек вызовов|Постоянная (`O(1)`)|
|Скорость|Может быть медленнее|Часто быстрее|
|Риск переполнения стека|Есть|Нет|

---

## Выводы
- Рекурсия — мощный инструмент, особенно в задачах с естественной иерархией (деревья, графы).
- Главное — правильно определить базовый случай, иначе программа «зависнет».
- Почти любой рекурсивный алгоритм можно переписать в итеративной форме, иногда с явным использованием стека.
3. Формальная постановка задачи сортировки списков/массивов. Классификация алгоритмов сортировки по различным критериям. Прямые и улучшенные алгоритмы сортировки. Привести примеры прямого и улучшенного алгоритма сортировки, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.

4. Формальная постановка задачи поиска образа в строке. Классификация алгоритмов поиска образа. Прямые и улучшенные алгоритмы поиска образа. Привести примеры прямого и улучшенного алгоритма поиска образа в строке, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.

5. Понятие и формальное определение графа. Представление графов в памяти вычислительной машины. Обход графа в глубину, обход графа в ширину. Привести примеры алгоритмов обхода в глубину и ширину, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.

6. Формальная постановка задачи поиска кратчайших путей в графе. Описать алгоритмы Дейкстры и Флойда, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.

7. Формальная постановка задачи построения минимального остовного дерева графа. Описать алгоритмы Прима и Крускала, соответственно (словесно или с использованием схем). Показать их вычислительную сложность.

8. Методы сжатия данных без потерь. Привести пример алгоритма сжатия без потерь (словесно или с использованием схем). Определить его вычислительную сложность.
9. Методы сжатия данных с потерями. Привести пример алгоритм сжатия с потерями (словесно или с использованием схем). Показать его вычислительную сложность.
