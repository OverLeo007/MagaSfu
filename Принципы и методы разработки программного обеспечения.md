# Билет 1

## Жизненный цикл (ЖЦ) программного продукта: модели ЖЦ; стандарты ЖЦ.

---

## Жизненный цикл программного продукта

- Совокупность последовательных этапов создания, эксплуатации и поддержки ПО.
    
- Включает планирование, разработку, тестирование, внедрение, сопровождение и вывод из эксплуатации.
    

---

## Модели жизненного цикла

1. **Каскадная модель (Waterfall)**
    
    - Линейный последовательный процесс: требования → проектирование → реализация → тестирование → внедрение → сопровождение.
        
    - Преимущества: простота, ясная структура.
        
    - Недостатки: слабая гибкость, сложно учитывать изменения.
        
2. **V-модель**
    
    - Расширение каскадной с акцентом на тестирование, где каждый этап разработки соответствует этапу тестирования.
        
3. **Инкрементная модель**
    
    - ПО создаётся частями (инкрементами), которые поочерёдно разрабатываются и интегрируются.
        
4. **Спиральная модель**
    
    - Итеративный процесс с акцентом на анализ рисков и постепенное уточнение требований.
        
5. **Аджайл-модели (Scrum, Kanban и др.)**
    
    - Гибкие подходы с итеративной разработкой, частыми релизами и активным взаимодействием с заказчиком.
        

---

## Стандарты жизненного цикла

- **ISO/IEC 12207** — международный стандарт, описывающий процессы жизненного цикла ПО.
    
- **CMMI (Capability Maturity Model Integration)** — модель зрелости процессов для повышения качества разработки.
    
- **ISO/IEC 15288** — стандарт для системной инженерии, охватывающий жизненный цикл систем.
    

---

## Выводы

- ЖЦ определяет структуру и порядок разработки ПО.
    
- Выбор модели зависит от требований, размера проекта и гибкости.
    
- Стандарты обеспечивают системность, качество и управляемость процесса разработки.
# Билет 2

## Методологии гибкой разработки программного обеспечения. Понятие о Agile, Scrum и Kanban.

---

## Методологии гибкой разработки (Agile)

- Подход к разработке ПО, ориентированный на **быструю адаптацию к изменениям**, частые поставки и тесное взаимодействие с заказчиком.
    
- Основные принципы Agile изложены в **Манифесте Agile**:
    
    - Люди и взаимодействия важнее процессов и инструментов
        
    - Работающий продукт важнее исчерпывающей документации
        
    - Сотрудничество с заказчиком важнее согласования условий договора
        
    - Готовность к изменениям важнее следования первоначальному плану
        

---

## Scrum

- Одна из наиболее популярных Agile-методологий.
    
- Основана на итеративной разработке, называемой **спринтами** (обычно 2–4 недели).
    
- Ключевые роли:
    
    - **Product Owner** — отвечает за продукт и формирование задач (бэклога)
        
    - **Scrum Master** — фасилитатор процесса, устраняет препятствия
        
    - **Команда разработчиков** — кросс-функциональная группа, выполняющая задачи
        
- Основные артефакты: бэклог продукта, бэклог спринта, ежедневные стендапы, обзор и ретроспектива спринта.
    

---

## Kanban

- Методология визуального управления задачами.
    
- Использует **доску Kanban** с колонками (например: "Запланировано", "В работе", "Готово").
    
- Цель — оптимизация потока задач, ограничение количества одновременно выполняемых задач (WIP - Work In Progress).
    
- Позволяет гибко управлять приоритетами и адаптироваться без фиксированных итераций.
    

---

## Сравнение Scrum и Kanban

|Характеристика|Scrum|Kanban|
|---|---|---|
|Итерации|Фиксированные спринты|Непрерывный поток задач|
|Роли|Определённые роли (Product Owner, Scrum Master)|Нет фиксированных ролей|
|Ограничения WIP|Нет жёстких ограничений в спринте|Ограничение числа задач в работе|
|Изменения|Изменения запрещены в спринте|Изменения возможны в любой момент|

---

## Выводы

- Agile обеспечивает гибкость и быструю реакцию на изменения.
    
- Scrum хорошо подходит для проектов с чёткой структурой и командой.
    
- Kanban — визуальный и гибкий инструмент для непрерывного улучшения.
    
- Выбор методологии зависит от специфики проекта и команды.
# Билет 3

## Тестирование программного обеспечения. Уровни и виды тестирования. Разработка через тестирование.

---

## Тестирование программного обеспечения (ПО)

- Процесс проверки и оценки качества ПО для выявления ошибок и соответствия требованиям.
    
- Обеспечивает надёжность, безопасность и соответствие ожиданиям пользователей.
    

---

## Уровни тестирования

1. **Модульное (Unit Testing)**
    
    - Проверка отдельных компонентов или функций.
        
    - Выполняется разработчиками.
        
2. **Интеграционное (Integration Testing)**
    
    - Тестирование взаимодействия между модулями.
        
    - Выявляет ошибки в интерфейсах и совместимости.
        
3. **Системное (System Testing)**
    
    - Полное тестирование всей системы в целом.
        
    - Проверка соответствия функциональных и нефункциональных требований.
        
4. **Приёмочное (Acceptance Testing)**
    
    - Оценка готовности системы к эксплуатации заказчиком.
        
    - Проверка удовлетворения бизнес-требований.
        

---

## Виды тестирования

- **Функциональное** — проверка соответствия функциональных требований.
    
- **Нефункциональное** — тестирование производительности, безопасности, удобства и т.д.
    
- **Регрессионное** — проверка, что исправления не нарушили существующий функционал.
    
- **Тестирование черного ящика** — проверка без знания внутренней структуры.
    
- **Тестирование белого ящика** — с учётом внутренней логики и кода.
    

---

## Разработка через тестирование (TDD — Test-Driven Development)

- Методология разработки, при которой сначала пишутся автоматические тесты, затем код, проходящий эти тесты.
    
- Цикл TDD: написать тест → запустить тест (ожидание провала) → написать код → запустить тест (успех) → рефакторинг.
    
- Обеспечивает высокое покрытие тестами и улучшает качество кода.
    

---

## Выводы

- Тестирование — ключевой этап обеспечения качества ПО.
    
- Различные уровни и виды тестирования покрывают разные аспекты проверки.
    
- TDD помогает создавать устойчивый и проверенный код с самого начала разработки.
# Билет 4

## Основные принципы объектно-ориентированного программирования. Классы и объекты. Методы и свойства. Абстракция. Инкапсуляция. Декомпозиция и модуляризация.

---

## Объектно-ориентированное программирование (ООП)

- Парадигма программирования, основанная на использовании **объектов** — экземпляров классов, объединяющих данные и поведение.
    

---

## Классы и объекты

- **Класс** — шаблон или описание структуры данных и методов (поведения).
    
- **Объект** — конкретный экземпляр класса с собственными значениями свойств.
    

---

## Методы и свойства

- **Свойства (атрибуты)** — данные, хранящие состояние объекта.
    
- **Методы** — функции, определённые в классе, которые описывают поведение объектов.
    

---

## Абстракция

- Выделение существенных характеристик объекта, игнорирование несущественных деталей.
    
- Позволяет работать с объектами через интерфейсы, не раскрывая внутреннюю реализацию.
    

---

## Инкапсуляция

- Сокрытие внутреннего состояния объекта и предоставление доступа только через методы.
    
- Обеспечивает защиту данных и контроль над изменениями.
    

---

## Декомпозиция и модуляризация

- **Декомпозиция** — разбиение сложной системы на более простые части (модули или классы).
    
- **Модуляризация** — организация кода в независимые модули, облегчающие понимание, поддержку и повторное использование.
    

---

## Выводы

- ООП строится на классах и объектах, объединяющих данные и поведение.
    
- Абстракция и инкапсуляция обеспечивают управление сложностью и безопасность данных.
    
- Декомпозиция и модуляризация повышают качество и масштабируемость программ.
# Билет 5

## Основные принципы объектно-ориентированного программирования. Связность и связанность. Наследование. Агрегация и композиция. Полиморфизм.

---

## Основные принципы ООП

- Объектно-ориентированное программирование основывается на следующих ключевых концепциях:
    
    - **Наследование**
        
    - **Полиморфизм**
        
    - **Инкапсуляция**
        
    - **Абстракция**
        

---

## Связность и связанность

- **Связность (Coupling)** — степень зависимости между модулями или классами.
    
    - Низкая связность предпочтительна — модули меньше зависят друг от друга, легче поддерживаются.
        
- **Связанность (Cohesion)** — степень внутренней связности элементов внутри модуля или класса.
    
    - Высокая связанность означает, что элементы класса/модуля тесно связаны и выполняют одну задачу.
        

---

## Наследование

- Механизм создания нового класса на основе существующего (родительского).
    
- Новый класс (подкласс) наследует свойства и методы родителя, может расширять или переопределять их.
    
- Позволяет повторно использовать код и создавать иерархии.
    

---

## Агрегация и композиция

- Способы организации отношений "часть-целое" между объектами.
    
- **Агрегация**
    
    - Отношение слабой зависимости, где часть может существовать независимо от целого.
        
    - Пример: класс «Отдел» содержит сотрудников, но сотрудники могут существовать отдельно.
        
- **Композиция**
    
    - Отношение сильной зависимости, где часть не может существовать без целого.
        
    - Пример: класс «Автомобиль» содержит двигатель — без автомобиля двигатель не существует.
        

---

## Полиморфизм

- Способность объектов разных классов реагировать на одинаковые вызовы методов по-разному.
    
- Позволяет использовать один интерфейс для работы с разными типами объектов.
    
- Основывается на переопределении методов в подклассах.
    

---

## Выводы

- Связность и связанность — ключевые характеристики качества модульности.
    
- Наследование упрощает повторное использование и расширяемость.
    
- Агрегация и композиция описывают разные уровни связей между объектами.
    
- Полиморфизм обеспечивает гибкость и расширяемость кода.
# Билет 6

## Прогнозирующие методологии разработки программного обеспечения. Основные принципы методологии RUP.

---

## Прогнозирующие методологии разработки ПО

- Подходы с чётко определёнными этапами и последовательностью действий.
    
- Фокусируются на детальном планировании и минимизации изменений в процессе разработки.
    
- Часто применяются в проектах с хорошо известными требованиями и стабильной средой.
    

---

## Rational Unified Process (RUP)

- Итеративный, архитектурно-ориентированный процесс разработки ПО, разработанный IBM Rational.
    
- Интегрирует лучшие практики и стандарты индустрии.
    
- Позволяет управлять сложностью проектов через разделение на фазы и дисциплины.
    

---

## Основные принципы RUP

1. **Итеративность**
    
    - Разработка проходит через повторяющиеся циклы (итерации) с постепенным уточнением требований и архитектуры.
        
2. **Управление требованиями**
    
    - Чёткое определение, анализ и отслеживание требований на всех этапах.
        
3. **Архитектурно-ориентированный подход**
    
    - Акцент на создании базовой архитектуры системы на ранних этапах.
        
4. **Постоянная проверка качества**
    
    - Регулярное тестирование и интеграция для выявления ошибок и проблем.
        
5. **Управление изменениями**
    
    - Контроль и адаптация к изменениям требований и среды.
        
6. **Поддержка командной работы**
    
    - Чёткое распределение ролей, коммуникация и координация участников проекта.
        

---

## Фазы RUP

- **Начало (Inception)** — определение целей, рисков и бизнес-контекста.
    
- **Проработка (Elaboration)** — разработка архитектуры, детальное планирование.
    
- **Конструкция (Construction)** — разработка, интеграция и тестирование.
    
- **Передача (Transition)** — внедрение и подготовка к эксплуатации.
    

---

## Выводы

- Прогнозирующие методологии подходят для проектов с предсказуемыми требованиями.
    
- RUP сочетает итеративность с чёткой структурой и дисциплинами.
    
- Основные принципы RUP способствуют контролю качества и управлению сложностью.
    
- Применение RUP улучшает управляемость и результативность разработки.
# Билет 7

## Понятие шаблона проектирования. Классификация и примеры шаблонов проектирования.

---

## Шаблон проектирования (Design Pattern)

- Проверенное временем, повторно используемое решение типичной задачи проектирования программного обеспечения.
    
- Представляет собой обобщённый подход, описывающий структуру, поведение и взаимодействие классов и объектов.
    
- Позволяет повысить качество, читаемость и поддержку кода.
    

---

## Классификация шаблонов проектирования (по GoF)

1. **Порождающие (Creational)**
    
    - Управляют созданием объектов, скрывая детали инстанцирования.
        
    - Примеры:
        
        - **Singleton** — гарантирует единственный экземпляр класса.
            
        - **Factory Method** — определяет интерфейс для создания объекта, позволяя подклассам решать, какой класс создавать.
            
        - **Builder** — отделяет конструирование сложного объекта от его представления.
            
2. **Структурные (Structural)**
    
    - Определяют способы компоновки классов и объектов в большие структуры.
        
    - Примеры:
        
        - **Adapter** — преобразует интерфейс класса в другой интерфейс, ожидаемый клиентом.
            
        - **Decorator** — динамически добавляет объектам новые обязанности.
            
        - **Composite** — строит древовидные структуры, позволяя работать с объектами и группами одинаково.
            
3. **Поведенческие (Behavioral)**
    
    - Управляют взаимодействием и ответственностью между объектами.
        
    - Примеры:
        
        - **Observer** — определяет зависимость «один-ко-многим», при изменении объекта оповещаются все зависимые.
            
        - **Strategy** — определяет семейство алгоритмов и инкапсулирует каждый из них.
            
        - **Command** — инкапсулирует запрос как объект, позволяя параметризовать клиентов.
            

---

## Пример шаблона — Приспособленец (Flyweight)

- Цель: **экономить память**, разделяя общие данные между множеством объектов вместо хранения их в каждом объекте.
    
- Используется, когда создаётся большое количество похожих объектов с повторяющимися состояниями.
    

---

## Как работает

- Выделяет **внутреннее состояние** — общее и неизменное, которое разделяется между объектами.
    
- Внешнее состояние хранится отдельно и передаётся объекту при необходимости.
    
- Обеспечивает значительное сокращение использования памяти.
    

---

## Пример применения

- В текстовых редакторах для представления символов: каждый символ — объект Flyweight, разделяющий шрифт, размер и стиль, а позиция символа — внешнее состояние.
    
- Игры с множеством однотипных объектов (например, деревья в лесу).
---

## Выводы

- Шаблоны проектирования обеспечивают стандартизированные решения для типовых проблем.
    
- Классификация делит шаблоны на порождающие, структурные и поведенческие.
    
- Использование шаблонов улучшает гибкость, расширяемость и поддержку кода.